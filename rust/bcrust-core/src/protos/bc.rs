// This file is generated by rust-protobuf 2.0.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct HelpResponse {
    // message fields
    pub help_text: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl HelpResponse {
    pub fn new() -> HelpResponse {
        ::std::default::Default::default()
    }

    // string help_text = 1;

    pub fn clear_help_text(&mut self) {
        self.help_text.clear();
    }

    // Param is passed by value, moved
    pub fn set_help_text(&mut self, v: ::std::string::String) {
        self.help_text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help_text(&mut self) -> &mut ::std::string::String {
        &mut self.help_text
    }

    // Take field
    pub fn take_help_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.help_text, ::std::string::String::new())
    }

    pub fn get_help_text(&self) -> &str {
        &self.help_text
    }
}

impl ::protobuf::Message for HelpResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.help_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.help_text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.help_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.help_text.is_empty() {
            os.write_string(1, &self.help_text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelpResponse {
        HelpResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "help_text",
                    |m: &HelpResponse| { &m.help_text },
                    |m: &mut HelpResponse| { &mut m.help_text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelpResponse>(
                    "HelpResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelpResponse {
        static mut instance: ::protobuf::lazy::Lazy<HelpResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelpResponse,
        };
        unsafe {
            instance.get(HelpResponse::new)
        }
    }
}

impl ::protobuf::Clear for HelpResponse {
    fn clear(&mut self) {
        self.clear_help_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelpResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelpResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatsResponse {
    // message fields
    pub calls: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StatsResponse {
    pub fn new() -> StatsResponse {
        ::std::default::Default::default()
    }

    // int64 calls = 1;

    pub fn clear_calls(&mut self) {
        self.calls = 0;
    }

    // Param is passed by value, moved
    pub fn set_calls(&mut self, v: i64) {
        self.calls = v;
    }

    pub fn get_calls(&self) -> i64 {
        self.calls
    }
}

impl ::protobuf::Message for StatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.calls = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.calls != 0 {
            my_size += ::protobuf::rt::value_size(1, self.calls, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.calls != 0 {
            os.write_int64(1, self.calls)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatsResponse {
        StatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "calls",
                    |m: &StatsResponse| { &m.calls },
                    |m: &mut StatsResponse| { &mut m.calls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatsResponse>(
                    "StatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatsResponse,
        };
        unsafe {
            instance.get(StatsResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatsResponse {
    fn clear(&mut self) {
        self.clear_calls();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcTransaction {
    // message fields
    pub from_addr: ::std::string::String,
    pub to_addr: ::std::string::String,
    pub amount: ::std::string::String,
    pub tx_fee: ::std::string::String,
    pub private_key_hex: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RpcTransaction {
    pub fn new() -> RpcTransaction {
        ::std::default::Default::default()
    }

    // string from_addr = 1;

    pub fn clear_from_addr(&mut self) {
        self.from_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_addr(&mut self, v: ::std::string::String) {
        self.from_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_addr(&mut self) -> &mut ::std::string::String {
        &mut self.from_addr
    }

    // Take field
    pub fn take_from_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_addr, ::std::string::String::new())
    }

    pub fn get_from_addr(&self) -> &str {
        &self.from_addr
    }

    // string to_addr = 2;

    pub fn clear_to_addr(&mut self) {
        self.to_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_addr(&mut self, v: ::std::string::String) {
        self.to_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_addr(&mut self) -> &mut ::std::string::String {
        &mut self.to_addr
    }

    // Take field
    pub fn take_to_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to_addr, ::std::string::String::new())
    }

    pub fn get_to_addr(&self) -> &str {
        &self.to_addr
    }

    // string amount = 3;

    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    pub fn get_amount(&self) -> &str {
        &self.amount
    }

    // string tx_fee = 4;

    pub fn clear_tx_fee(&mut self) {
        self.tx_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_fee(&mut self, v: ::std::string::String) {
        self.tx_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_fee(&mut self) -> &mut ::std::string::String {
        &mut self.tx_fee
    }

    // Take field
    pub fn take_tx_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_fee, ::std::string::String::new())
    }

    pub fn get_tx_fee(&self) -> &str {
        &self.tx_fee
    }

    // string private_key_hex = 5;

    pub fn clear_private_key_hex(&mut self) {
        self.private_key_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_key_hex(&mut self, v: ::std::string::String) {
        self.private_key_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key_hex(&mut self) -> &mut ::std::string::String {
        &mut self.private_key_hex
    }

    // Take field
    pub fn take_private_key_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.private_key_hex, ::std::string::String::new())
    }

    pub fn get_private_key_hex(&self) -> &str {
        &self.private_key_hex
    }
}

impl ::protobuf::Message for RpcTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_addr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_fee)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.private_key_hex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from_addr);
        }
        if !self.to_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to_addr);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.amount);
        }
        if !self.tx_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tx_fee);
        }
        if !self.private_key_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.private_key_hex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from_addr.is_empty() {
            os.write_string(1, &self.from_addr)?;
        }
        if !self.to_addr.is_empty() {
            os.write_string(2, &self.to_addr)?;
        }
        if !self.amount.is_empty() {
            os.write_string(3, &self.amount)?;
        }
        if !self.tx_fee.is_empty() {
            os.write_string(4, &self.tx_fee)?;
        }
        if !self.private_key_hex.is_empty() {
            os.write_string(5, &self.private_key_hex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcTransaction {
        RpcTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_addr",
                    |m: &RpcTransaction| { &m.from_addr },
                    |m: &mut RpcTransaction| { &mut m.from_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to_addr",
                    |m: &RpcTransaction| { &m.to_addr },
                    |m: &mut RpcTransaction| { &mut m.to_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "amount",
                    |m: &RpcTransaction| { &m.amount },
                    |m: &mut RpcTransaction| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_fee",
                    |m: &RpcTransaction| { &m.tx_fee },
                    |m: &mut RpcTransaction| { &mut m.tx_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "private_key_hex",
                    |m: &RpcTransaction| { &m.private_key_hex },
                    |m: &mut RpcTransaction| { &mut m.private_key_hex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcTransaction>(
                    "RpcTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcTransaction {
        static mut instance: ::protobuf::lazy::Lazy<RpcTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcTransaction,
        };
        unsafe {
            instance.get(RpcTransaction::new)
        }
    }
}

impl ::protobuf::Clear for RpcTransaction {
    fn clear(&mut self) {
        self.clear_from_addr();
        self.clear_to_addr();
        self.clear_amount();
        self.clear_tx_fee();
        self.clear_private_key_hex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RpcTransactionResponse {
    // message fields
    pub status: RpcTransactionResponseStatus,
    pub tx_hash: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RpcTransactionResponse {
    pub fn new() -> RpcTransactionResponse {
        ::std::default::Default::default()
    }

    // .bc.RpcTransactionResponseStatus status = 1;

    pub fn clear_status(&mut self) {
        self.status = RpcTransactionResponseStatus::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RpcTransactionResponseStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> RpcTransactionResponseStatus {
        self.status
    }

    // string tx_hash = 2;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // string error = 3;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }
}

impl ::protobuf::Message for RpcTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != RpcTransactionResponseStatus::Success {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tx_hash);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != RpcTransactionResponseStatus::Success {
            os.write_enum(1, self.status.value())?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(2, &self.tx_hash)?;
        }
        if !self.error.is_empty() {
            os.write_string(3, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcTransactionResponse {
        RpcTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RpcTransactionResponseStatus>>(
                    "status",
                    |m: &RpcTransactionResponse| { &m.status },
                    |m: &mut RpcTransactionResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &RpcTransactionResponse| { &m.tx_hash },
                    |m: &mut RpcTransactionResponse| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &RpcTransactionResponse| { &m.error },
                    |m: &mut RpcTransactionResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcTransactionResponse>(
                    "RpcTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<RpcTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcTransactionResponse,
        };
        unsafe {
            instance.get(RpcTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for RpcTransactionResponse {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_tx_hash();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transfer {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::string::String,
    pub amount: ::std::string::String,
    pub tx_hash: ::std::string::String,
    pub tx_output_index: u32,
    pub timestamp: u64,
    pub height: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Transfer {
    pub fn new() -> Transfer {
        ::std::default::Default::default()
    }

    // string from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    pub fn get_from(&self) -> &str {
        &self.from
    }

    // string to = 2;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to, ::std::string::String::new())
    }

    pub fn get_to(&self) -> &str {
        &self.to
    }

    // string amount = 3;

    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    pub fn get_amount(&self) -> &str {
        &self.amount
    }

    // string tx_hash = 4;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // uint32 tx_output_index = 5;

    pub fn clear_tx_output_index(&mut self) {
        self.tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_index(&mut self, v: u32) {
        self.tx_output_index = v;
    }

    pub fn get_tx_output_index(&self) -> u32 {
        self.tx_output_index
    }

    // uint64 timestamp = 6;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 height = 7;

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    pub fn get_height(&self) -> u64 {
        self.height
    }
}

impl ::protobuf::Message for Transfer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_output_index = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.amount);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tx_hash);
        }
        if self.tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_string(2, &self.to)?;
        }
        if !self.amount.is_empty() {
            os.write_string(3, &self.amount)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(4, &self.tx_hash)?;
        }
        if self.tx_output_index != 0 {
            os.write_uint32(5, self.tx_output_index)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(6, self.timestamp)?;
        }
        if self.height != 0 {
            os.write_uint64(7, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transfer {
        Transfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from",
                    |m: &Transfer| { &m.from },
                    |m: &mut Transfer| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to",
                    |m: &Transfer| { &m.to },
                    |m: &mut Transfer| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "amount",
                    |m: &Transfer| { &m.amount },
                    |m: &mut Transfer| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &Transfer| { &m.tx_hash },
                    |m: &mut Transfer| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_output_index",
                    |m: &Transfer| { &m.tx_output_index },
                    |m: &mut Transfer| { &mut m.tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &Transfer| { &m.timestamp },
                    |m: &mut Transfer| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "height",
                    |m: &Transfer| { &m.height },
                    |m: &mut Transfer| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transfer>(
                    "Transfer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transfer {
        static mut instance: ::protobuf::lazy::Lazy<Transfer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transfer,
        };
        unsafe {
            instance.get(Transfer::new)
        }
    }
}

impl ::protobuf::Clear for Transfer {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_to();
        self.clear_amount();
        self.clear_tx_hash();
        self.clear_tx_output_index();
        self.clear_timestamp();
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transfer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TransferRequest {
    pub fn new() -> TransferRequest {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }
}

impl ::protobuf::Message for TransferRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferRequest {
        TransferRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &TransferRequest| { &m.address },
                    |m: &mut TransferRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferRequest>(
                    "TransferRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferRequest {
        static mut instance: ::protobuf::lazy::Lazy<TransferRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferRequest,
        };
        unsafe {
            instance.get(TransferRequest::new)
        }
    }
}

impl ::protobuf::Clear for TransferRequest {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferResponse {
    // message fields
    pub transfers: ::protobuf::RepeatedField<Transfer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TransferResponse {
    pub fn new() -> TransferResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.Transfer transfers = 1;

    pub fn clear_transfers(&mut self) {
        self.transfers.clear();
    }

    // Param is passed by value, moved
    pub fn set_transfers(&mut self, v: ::protobuf::RepeatedField<Transfer>) {
        self.transfers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transfers(&mut self) -> &mut ::protobuf::RepeatedField<Transfer> {
        &mut self.transfers
    }

    // Take field
    pub fn take_transfers(&mut self) -> ::protobuf::RepeatedField<Transfer> {
        ::std::mem::replace(&mut self.transfers, ::protobuf::RepeatedField::new())
    }

    pub fn get_transfers(&self) -> &[Transfer] {
        &self.transfers
    }
}

impl ::protobuf::Message for TransferResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transfers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transfers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transfers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transfers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferResponse {
        TransferResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transfer>>(
                    "transfers",
                    |m: &TransferResponse| { &m.transfers },
                    |m: &mut TransferResponse| { &mut m.transfers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferResponse>(
                    "TransferResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferResponse {
        static mut instance: ::protobuf::lazy::Lazy<TransferResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferResponse,
        };
        unsafe {
            instance.get(TransferResponse::new)
        }
    }
}

impl ::protobuf::Clear for TransferResponse {
    fn clear(&mut self) {
        self.clear_transfers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUtxoLengthRequest {
    // message fields
    pub script_type: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetUtxoLengthRequest {
    pub fn new() -> GetUtxoLengthRequest {
        ::std::default::Default::default()
    }

    // string script_type = 1;

    pub fn clear_script_type(&mut self) {
        self.script_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_script_type(&mut self, v: ::std::string::String) {
        self.script_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script_type(&mut self) -> &mut ::std::string::String {
        &mut self.script_type
    }

    // Take field
    pub fn take_script_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.script_type, ::std::string::String::new())
    }

    pub fn get_script_type(&self) -> &str {
        &self.script_type
    }
}

impl ::protobuf::Message for GetUtxoLengthRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.script_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.script_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.script_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.script_type.is_empty() {
            os.write_string(1, &self.script_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUtxoLengthRequest {
        GetUtxoLengthRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "script_type",
                    |m: &GetUtxoLengthRequest| { &m.script_type },
                    |m: &mut GetUtxoLengthRequest| { &mut m.script_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetUtxoLengthRequest>(
                    "GetUtxoLengthRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetUtxoLengthRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetUtxoLengthRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetUtxoLengthRequest,
        };
        unsafe {
            instance.get(GetUtxoLengthRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetUtxoLengthRequest {
    fn clear(&mut self) {
        self.clear_script_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUtxoLengthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUtxoLengthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUtxoLengthResponse {
    // message fields
    pub length: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetUtxoLengthResponse {
    pub fn new() -> GetUtxoLengthResponse {
        ::std::default::Default::default()
    }

    // uint32 length = 1;

    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = v;
    }

    pub fn get_length(&self) -> u32 {
        self.length
    }
}

impl ::protobuf::Message for GetUtxoLengthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(1, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.length != 0 {
            os.write_uint32(1, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUtxoLengthResponse {
        GetUtxoLengthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "length",
                    |m: &GetUtxoLengthResponse| { &m.length },
                    |m: &mut GetUtxoLengthResponse| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetUtxoLengthResponse>(
                    "GetUtxoLengthResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetUtxoLengthResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetUtxoLengthResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetUtxoLengthResponse,
        };
        unsafe {
            instance.get(GetUtxoLengthResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetUtxoLengthResponse {
    fn clear(&mut self) {
        self.clear_length();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUtxoLengthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUtxoLengthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSpendableCollateralRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetSpendableCollateralRequest {
    pub fn new() -> GetSpendableCollateralRequest {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }
}

impl ::protobuf::Message for GetSpendableCollateralRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSpendableCollateralRequest {
        GetSpendableCollateralRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &GetSpendableCollateralRequest| { &m.address },
                    |m: &mut GetSpendableCollateralRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSpendableCollateralRequest>(
                    "GetSpendableCollateralRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSpendableCollateralRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSpendableCollateralRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSpendableCollateralRequest,
        };
        unsafe {
            instance.get(GetSpendableCollateralRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetSpendableCollateralRequest {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSpendableCollateralRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSpendableCollateralRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSpendableCollateralResponse {
    // message fields
    pub outpoints: ::protobuf::RepeatedField<super::core::OutPoint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetSpendableCollateralResponse {
    pub fn new() -> GetSpendableCollateralResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.OutPoint outpoints = 1;

    pub fn clear_outpoints(&mut self) {
        self.outpoints.clear();
    }

    // Param is passed by value, moved
    pub fn set_outpoints(&mut self, v: ::protobuf::RepeatedField<super::core::OutPoint>) {
        self.outpoints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outpoints(&mut self) -> &mut ::protobuf::RepeatedField<super::core::OutPoint> {
        &mut self.outpoints
    }

    // Take field
    pub fn take_outpoints(&mut self) -> ::protobuf::RepeatedField<super::core::OutPoint> {
        ::std::mem::replace(&mut self.outpoints, ::protobuf::RepeatedField::new())
    }

    pub fn get_outpoints(&self) -> &[super::core::OutPoint] {
        &self.outpoints
    }
}

impl ::protobuf::Message for GetSpendableCollateralResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.outpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outpoints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outpoints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outpoints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSpendableCollateralResponse {
        GetSpendableCollateralResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::core::OutPoint>>(
                    "outpoints",
                    |m: &GetSpendableCollateralResponse| { &m.outpoints },
                    |m: &mut GetSpendableCollateralResponse| { &mut m.outpoints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSpendableCollateralResponse>(
                    "GetSpendableCollateralResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSpendableCollateralResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetSpendableCollateralResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSpendableCollateralResponse,
        };
        unsafe {
            instance.get(GetSpendableCollateralResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetSpendableCollateralResponse {
    fn clear(&mut self) {
        self.clear_outpoints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSpendableCollateralResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSpendableCollateralResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBalanceRequest {
    pub fn new() -> GetBalanceRequest {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }
}

impl ::protobuf::Message for GetBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceRequest {
        GetBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &GetBalanceRequest| { &m.address },
                    |m: &mut GetBalanceRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceRequest>(
                    "GetBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceRequest,
        };
        unsafe {
            instance.get(GetBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceRequest {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceResponse {
    // message fields
    pub confirmed: ::std::string::String,
    pub unconfirmed: ::std::string::String,
    pub collateralized: ::std::string::String,
    pub unlockable: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBalanceResponse {
    pub fn new() -> GetBalanceResponse {
        ::std::default::Default::default()
    }

    // string confirmed = 1;

    pub fn clear_confirmed(&mut self) {
        self.confirmed.clear();
    }

    // Param is passed by value, moved
    pub fn set_confirmed(&mut self, v: ::std::string::String) {
        self.confirmed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confirmed(&mut self) -> &mut ::std::string::String {
        &mut self.confirmed
    }

    // Take field
    pub fn take_confirmed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.confirmed, ::std::string::String::new())
    }

    pub fn get_confirmed(&self) -> &str {
        &self.confirmed
    }

    // string unconfirmed = 2;

    pub fn clear_unconfirmed(&mut self) {
        self.unconfirmed.clear();
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed(&mut self, v: ::std::string::String) {
        self.unconfirmed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unconfirmed(&mut self) -> &mut ::std::string::String {
        &mut self.unconfirmed
    }

    // Take field
    pub fn take_unconfirmed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unconfirmed, ::std::string::String::new())
    }

    pub fn get_unconfirmed(&self) -> &str {
        &self.unconfirmed
    }

    // string collateralized = 3;

    pub fn clear_collateralized(&mut self) {
        self.collateralized.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized(&mut self, v: ::std::string::String) {
        self.collateralized = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized
    }

    // Take field
    pub fn take_collateralized(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized, ::std::string::String::new())
    }

    pub fn get_collateralized(&self) -> &str {
        &self.collateralized
    }

    // string unlockable = 4;

    pub fn clear_unlockable(&mut self) {
        self.unlockable.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlockable(&mut self, v: ::std::string::String) {
        self.unlockable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlockable(&mut self) -> &mut ::std::string::String {
        &mut self.unlockable
    }

    // Take field
    pub fn take_unlockable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unlockable, ::std::string::String::new())
    }

    pub fn get_unlockable(&self) -> &str {
        &self.unlockable
    }
}

impl ::protobuf::Message for GetBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.confirmed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unconfirmed)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unlockable)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.confirmed.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.confirmed);
        }
        if !self.unconfirmed.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.unconfirmed);
        }
        if !self.collateralized.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.collateralized);
        }
        if !self.unlockable.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unlockable);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.confirmed.is_empty() {
            os.write_string(1, &self.confirmed)?;
        }
        if !self.unconfirmed.is_empty() {
            os.write_string(2, &self.unconfirmed)?;
        }
        if !self.collateralized.is_empty() {
            os.write_string(3, &self.collateralized)?;
        }
        if !self.unlockable.is_empty() {
            os.write_string(4, &self.unlockable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceResponse {
        GetBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "confirmed",
                    |m: &GetBalanceResponse| { &m.confirmed },
                    |m: &mut GetBalanceResponse| { &mut m.confirmed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unconfirmed",
                    |m: &GetBalanceResponse| { &m.unconfirmed },
                    |m: &mut GetBalanceResponse| { &mut m.unconfirmed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized",
                    |m: &GetBalanceResponse| { &m.collateralized },
                    |m: &mut GetBalanceResponse| { &mut m.collateralized },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unlockable",
                    |m: &GetBalanceResponse| { &m.unlockable },
                    |m: &mut GetBalanceResponse| { &mut m.unlockable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceResponse>(
                    "GetBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceResponse,
        };
        unsafe {
            instance.get(GetBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceResponse {
    fn clear(&mut self) {
        self.clear_confirmed();
        self.clear_unconfirmed();
        self.clear_collateralized();
        self.clear_unlockable();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUnlockTakerTxParamsRequest {
    // message fields
    pub tx_hash: ::std::string::String,
    pub tx_output_index: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetUnlockTakerTxParamsRequest {
    pub fn new() -> GetUnlockTakerTxParamsRequest {
        ::std::default::Default::default()
    }

    // string tx_hash = 1;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // uint32 tx_output_index = 2;

    pub fn clear_tx_output_index(&mut self) {
        self.tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_index(&mut self, v: u32) {
        self.tx_output_index = v;
    }

    pub fn get_tx_output_index(&self) -> u32 {
        self.tx_output_index
    }
}

impl ::protobuf::Message for GetUnlockTakerTxParamsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_hash);
        }
        if self.tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_hash.is_empty() {
            os.write_string(1, &self.tx_hash)?;
        }
        if self.tx_output_index != 0 {
            os.write_uint32(2, self.tx_output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUnlockTakerTxParamsRequest {
        GetUnlockTakerTxParamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &GetUnlockTakerTxParamsRequest| { &m.tx_hash },
                    |m: &mut GetUnlockTakerTxParamsRequest| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_output_index",
                    |m: &GetUnlockTakerTxParamsRequest| { &m.tx_output_index },
                    |m: &mut GetUnlockTakerTxParamsRequest| { &mut m.tx_output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetUnlockTakerTxParamsRequest>(
                    "GetUnlockTakerTxParamsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetUnlockTakerTxParamsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetUnlockTakerTxParamsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetUnlockTakerTxParamsRequest,
        };
        unsafe {
            instance.get(GetUnlockTakerTxParamsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetUnlockTakerTxParamsRequest {
    fn clear(&mut self) {
        self.clear_tx_hash();
        self.clear_tx_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUnlockTakerTxParamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUnlockTakerTxParamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUnlockTakerTxParamsResponse {
    // message fields
    pub unlock_scripts: ::protobuf::RepeatedField<::std::string::String>,
    pub value_in_tx: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetUnlockTakerTxParamsResponse {
    pub fn new() -> GetUnlockTakerTxParamsResponse {
        ::std::default::Default::default()
    }

    // repeated string unlock_scripts = 1;

    pub fn clear_unlock_scripts(&mut self) {
        self.unlock_scripts.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlock_scripts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.unlock_scripts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlock_scripts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.unlock_scripts
    }

    // Take field
    pub fn take_unlock_scripts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.unlock_scripts, ::protobuf::RepeatedField::new())
    }

    pub fn get_unlock_scripts(&self) -> &[::std::string::String] {
        &self.unlock_scripts
    }

    // bytes value_in_tx = 2;

    pub fn clear_value_in_tx(&mut self) {
        self.value_in_tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_in_tx(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_in_tx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_in_tx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_in_tx
    }

    // Take field
    pub fn take_value_in_tx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_in_tx, ::std::vec::Vec::new())
    }

    pub fn get_value_in_tx(&self) -> &[u8] {
        &self.value_in_tx
    }
}

impl ::protobuf::Message for GetUnlockTakerTxParamsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.unlock_scripts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_in_tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unlock_scripts {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.value_in_tx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value_in_tx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unlock_scripts {
            os.write_string(1, &v)?;
        };
        if !self.value_in_tx.is_empty() {
            os.write_bytes(2, &self.value_in_tx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUnlockTakerTxParamsResponse {
        GetUnlockTakerTxParamsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "unlock_scripts",
                    |m: &GetUnlockTakerTxParamsResponse| { &m.unlock_scripts },
                    |m: &mut GetUnlockTakerTxParamsResponse| { &mut m.unlock_scripts },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value_in_tx",
                    |m: &GetUnlockTakerTxParamsResponse| { &m.value_in_tx },
                    |m: &mut GetUnlockTakerTxParamsResponse| { &mut m.value_in_tx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetUnlockTakerTxParamsResponse>(
                    "GetUnlockTakerTxParamsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetUnlockTakerTxParamsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetUnlockTakerTxParamsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetUnlockTakerTxParamsResponse,
        };
        unsafe {
            instance.get(GetUnlockTakerTxParamsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetUnlockTakerTxParamsResponse {
    fn clear(&mut self) {
        self.clear_unlock_scripts();
        self.clear_value_in_tx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUnlockTakerTxParamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUnlockTakerTxParamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MakerOrderInfo {
    // message fields
    pub trade_height: u64,
    pub deposit: u64,
    pub settlement: u64,
    pub shift_maker: u64,
    pub shift_taker: u64,
    pub sends_from_chain: ::std::string::String,
    pub receives_to_chain: ::std::string::String,
    pub sends_from_address: ::std::string::String,
    pub receives_to_address: ::std::string::String,
    pub sends_unit: ::std::string::String,
    pub receives_unit: ::std::string::String,
    pub double_hashed_bc_address: ::std::string::String,
    pub collateralized_nrg: ::std::string::String,
    pub nrg_unit: ::std::string::String,
    pub tx_hash: ::std::string::String,
    pub tx_output_index: u32,
    pub is_settled: bool,
    pub fixed_unit_fee: ::std::string::String,
    pub base: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MakerOrderInfo {
    pub fn new() -> MakerOrderInfo {
        ::std::default::Default::default()
    }

    // uint64 trade_height = 1;

    pub fn clear_trade_height(&mut self) {
        self.trade_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_height(&mut self, v: u64) {
        self.trade_height = v;
    }

    pub fn get_trade_height(&self) -> u64 {
        self.trade_height
    }

    // uint64 deposit = 2;

    pub fn clear_deposit(&mut self) {
        self.deposit = 0;
    }

    // Param is passed by value, moved
    pub fn set_deposit(&mut self, v: u64) {
        self.deposit = v;
    }

    pub fn get_deposit(&self) -> u64 {
        self.deposit
    }

    // uint64 settlement = 3;

    pub fn clear_settlement(&mut self) {
        self.settlement = 0;
    }

    // Param is passed by value, moved
    pub fn set_settlement(&mut self, v: u64) {
        self.settlement = v;
    }

    pub fn get_settlement(&self) -> u64 {
        self.settlement
    }

    // uint64 shift_maker = 4;

    pub fn clear_shift_maker(&mut self) {
        self.shift_maker = 0;
    }

    // Param is passed by value, moved
    pub fn set_shift_maker(&mut self, v: u64) {
        self.shift_maker = v;
    }

    pub fn get_shift_maker(&self) -> u64 {
        self.shift_maker
    }

    // uint64 shift_taker = 5;

    pub fn clear_shift_taker(&mut self) {
        self.shift_taker = 0;
    }

    // Param is passed by value, moved
    pub fn set_shift_taker(&mut self, v: u64) {
        self.shift_taker = v;
    }

    pub fn get_shift_taker(&self) -> u64 {
        self.shift_taker
    }

    // string sends_from_chain = 6;

    pub fn clear_sends_from_chain(&mut self) {
        self.sends_from_chain.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_from_chain(&mut self, v: ::std::string::String) {
        self.sends_from_chain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_from_chain(&mut self) -> &mut ::std::string::String {
        &mut self.sends_from_chain
    }

    // Take field
    pub fn take_sends_from_chain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_from_chain, ::std::string::String::new())
    }

    pub fn get_sends_from_chain(&self) -> &str {
        &self.sends_from_chain
    }

    // string receives_to_chain = 7;

    pub fn clear_receives_to_chain(&mut self) {
        self.receives_to_chain.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives_to_chain(&mut self, v: ::std::string::String) {
        self.receives_to_chain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receives_to_chain(&mut self) -> &mut ::std::string::String {
        &mut self.receives_to_chain
    }

    // Take field
    pub fn take_receives_to_chain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receives_to_chain, ::std::string::String::new())
    }

    pub fn get_receives_to_chain(&self) -> &str {
        &self.receives_to_chain
    }

    // string sends_from_address = 8;

    pub fn clear_sends_from_address(&mut self) {
        self.sends_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_from_address(&mut self, v: ::std::string::String) {
        self.sends_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_from_address(&mut self) -> &mut ::std::string::String {
        &mut self.sends_from_address
    }

    // Take field
    pub fn take_sends_from_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_from_address, ::std::string::String::new())
    }

    pub fn get_sends_from_address(&self) -> &str {
        &self.sends_from_address
    }

    // string receives_to_address = 9;

    pub fn clear_receives_to_address(&mut self) {
        self.receives_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives_to_address(&mut self, v: ::std::string::String) {
        self.receives_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receives_to_address(&mut self) -> &mut ::std::string::String {
        &mut self.receives_to_address
    }

    // Take field
    pub fn take_receives_to_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receives_to_address, ::std::string::String::new())
    }

    pub fn get_receives_to_address(&self) -> &str {
        &self.receives_to_address
    }

    // string sends_unit = 10;

    pub fn clear_sends_unit(&mut self) {
        self.sends_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_unit(&mut self, v: ::std::string::String) {
        self.sends_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_unit(&mut self) -> &mut ::std::string::String {
        &mut self.sends_unit
    }

    // Take field
    pub fn take_sends_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_unit, ::std::string::String::new())
    }

    pub fn get_sends_unit(&self) -> &str {
        &self.sends_unit
    }

    // string receives_unit = 11;

    pub fn clear_receives_unit(&mut self) {
        self.receives_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives_unit(&mut self, v: ::std::string::String) {
        self.receives_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receives_unit(&mut self) -> &mut ::std::string::String {
        &mut self.receives_unit
    }

    // Take field
    pub fn take_receives_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receives_unit, ::std::string::String::new())
    }

    pub fn get_receives_unit(&self) -> &str {
        &self.receives_unit
    }

    // string double_hashed_bc_address = 12;

    pub fn clear_double_hashed_bc_address(&mut self) {
        self.double_hashed_bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_double_hashed_bc_address(&mut self, v: ::std::string::String) {
        self.double_hashed_bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_double_hashed_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.double_hashed_bc_address
    }

    // Take field
    pub fn take_double_hashed_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.double_hashed_bc_address, ::std::string::String::new())
    }

    pub fn get_double_hashed_bc_address(&self) -> &str {
        &self.double_hashed_bc_address
    }

    // string collateralized_nrg = 13;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }

    // string nrg_unit = 14;

    pub fn clear_nrg_unit(&mut self) {
        self.nrg_unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_nrg_unit(&mut self, v: ::std::string::String) {
        self.nrg_unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nrg_unit(&mut self) -> &mut ::std::string::String {
        &mut self.nrg_unit
    }

    // Take field
    pub fn take_nrg_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nrg_unit, ::std::string::String::new())
    }

    pub fn get_nrg_unit(&self) -> &str {
        &self.nrg_unit
    }

    // string tx_hash = 15;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // uint32 tx_output_index = 16;

    pub fn clear_tx_output_index(&mut self) {
        self.tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_index(&mut self, v: u32) {
        self.tx_output_index = v;
    }

    pub fn get_tx_output_index(&self) -> u32 {
        self.tx_output_index
    }

    // bool is_settled = 17;

    pub fn clear_is_settled(&mut self) {
        self.is_settled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_settled(&mut self, v: bool) {
        self.is_settled = v;
    }

    pub fn get_is_settled(&self) -> bool {
        self.is_settled
    }

    // string fixed_unit_fee = 18;

    pub fn clear_fixed_unit_fee(&mut self) {
        self.fixed_unit_fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_fixed_unit_fee(&mut self, v: ::std::string::String) {
        self.fixed_unit_fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fixed_unit_fee(&mut self) -> &mut ::std::string::String {
        &mut self.fixed_unit_fee
    }

    // Take field
    pub fn take_fixed_unit_fee(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fixed_unit_fee, ::std::string::String::new())
    }

    pub fn get_fixed_unit_fee(&self) -> &str {
        &self.fixed_unit_fee
    }

    // uint32 base = 19;

    pub fn clear_base(&mut self) {
        self.base = 0;
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: u32) {
        self.base = v;
    }

    pub fn get_base(&self) -> u32 {
        self.base
    }
}

impl ::protobuf::Message for MakerOrderInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trade_height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deposit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settlement = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shift_maker = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shift_taker = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_from_chain)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receives_to_chain)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_from_address)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receives_to_address)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_unit)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receives_unit)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.double_hashed_bc_address)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nrg_unit)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_output_index = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_settled = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fixed_unit_fee)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.trade_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.trade_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deposit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deposit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settlement != 0 {
            my_size += ::protobuf::rt::value_size(3, self.settlement, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shift_maker != 0 {
            my_size += ::protobuf::rt::value_size(4, self.shift_maker, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shift_taker != 0 {
            my_size += ::protobuf::rt::value_size(5, self.shift_taker, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.sends_from_chain.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.sends_from_chain);
        }
        if !self.receives_to_chain.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.receives_to_chain);
        }
        if !self.sends_from_address.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.sends_from_address);
        }
        if !self.receives_to_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.receives_to_address);
        }
        if !self.sends_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sends_unit);
        }
        if !self.receives_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.receives_unit);
        }
        if !self.double_hashed_bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.double_hashed_bc_address);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.collateralized_nrg);
        }
        if !self.nrg_unit.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.nrg_unit);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.tx_hash);
        }
        if self.tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_settled != false {
            my_size += 3;
        }
        if !self.fixed_unit_fee.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.fixed_unit_fee);
        }
        if self.base != 0 {
            my_size += ::protobuf::rt::value_size(19, self.base, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.trade_height != 0 {
            os.write_uint64(1, self.trade_height)?;
        }
        if self.deposit != 0 {
            os.write_uint64(2, self.deposit)?;
        }
        if self.settlement != 0 {
            os.write_uint64(3, self.settlement)?;
        }
        if self.shift_maker != 0 {
            os.write_uint64(4, self.shift_maker)?;
        }
        if self.shift_taker != 0 {
            os.write_uint64(5, self.shift_taker)?;
        }
        if !self.sends_from_chain.is_empty() {
            os.write_string(6, &self.sends_from_chain)?;
        }
        if !self.receives_to_chain.is_empty() {
            os.write_string(7, &self.receives_to_chain)?;
        }
        if !self.sends_from_address.is_empty() {
            os.write_string(8, &self.sends_from_address)?;
        }
        if !self.receives_to_address.is_empty() {
            os.write_string(9, &self.receives_to_address)?;
        }
        if !self.sends_unit.is_empty() {
            os.write_string(10, &self.sends_unit)?;
        }
        if !self.receives_unit.is_empty() {
            os.write_string(11, &self.receives_unit)?;
        }
        if !self.double_hashed_bc_address.is_empty() {
            os.write_string(12, &self.double_hashed_bc_address)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(13, &self.collateralized_nrg)?;
        }
        if !self.nrg_unit.is_empty() {
            os.write_string(14, &self.nrg_unit)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(15, &self.tx_hash)?;
        }
        if self.tx_output_index != 0 {
            os.write_uint32(16, self.tx_output_index)?;
        }
        if self.is_settled != false {
            os.write_bool(17, self.is_settled)?;
        }
        if !self.fixed_unit_fee.is_empty() {
            os.write_string(18, &self.fixed_unit_fee)?;
        }
        if self.base != 0 {
            os.write_uint32(19, self.base)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MakerOrderInfo {
        MakerOrderInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "trade_height",
                    |m: &MakerOrderInfo| { &m.trade_height },
                    |m: &mut MakerOrderInfo| { &mut m.trade_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "deposit",
                    |m: &MakerOrderInfo| { &m.deposit },
                    |m: &mut MakerOrderInfo| { &mut m.deposit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settlement",
                    |m: &MakerOrderInfo| { &m.settlement },
                    |m: &mut MakerOrderInfo| { &mut m.settlement },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shift_maker",
                    |m: &MakerOrderInfo| { &m.shift_maker },
                    |m: &mut MakerOrderInfo| { &mut m.shift_maker },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shift_taker",
                    |m: &MakerOrderInfo| { &m.shift_taker },
                    |m: &mut MakerOrderInfo| { &mut m.shift_taker },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_from_chain",
                    |m: &MakerOrderInfo| { &m.sends_from_chain },
                    |m: &mut MakerOrderInfo| { &mut m.sends_from_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "receives_to_chain",
                    |m: &MakerOrderInfo| { &m.receives_to_chain },
                    |m: &mut MakerOrderInfo| { &mut m.receives_to_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_from_address",
                    |m: &MakerOrderInfo| { &m.sends_from_address },
                    |m: &mut MakerOrderInfo| { &mut m.sends_from_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "receives_to_address",
                    |m: &MakerOrderInfo| { &m.receives_to_address },
                    |m: &mut MakerOrderInfo| { &mut m.receives_to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_unit",
                    |m: &MakerOrderInfo| { &m.sends_unit },
                    |m: &mut MakerOrderInfo| { &mut m.sends_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "receives_unit",
                    |m: &MakerOrderInfo| { &m.receives_unit },
                    |m: &mut MakerOrderInfo| { &mut m.receives_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "double_hashed_bc_address",
                    |m: &MakerOrderInfo| { &m.double_hashed_bc_address },
                    |m: &mut MakerOrderInfo| { &mut m.double_hashed_bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &MakerOrderInfo| { &m.collateralized_nrg },
                    |m: &mut MakerOrderInfo| { &mut m.collateralized_nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nrg_unit",
                    |m: &MakerOrderInfo| { &m.nrg_unit },
                    |m: &mut MakerOrderInfo| { &mut m.nrg_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &MakerOrderInfo| { &m.tx_hash },
                    |m: &mut MakerOrderInfo| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_output_index",
                    |m: &MakerOrderInfo| { &m.tx_output_index },
                    |m: &mut MakerOrderInfo| { &mut m.tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_settled",
                    |m: &MakerOrderInfo| { &m.is_settled },
                    |m: &mut MakerOrderInfo| { &mut m.is_settled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fixed_unit_fee",
                    |m: &MakerOrderInfo| { &m.fixed_unit_fee },
                    |m: &mut MakerOrderInfo| { &mut m.fixed_unit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base",
                    |m: &MakerOrderInfo| { &m.base },
                    |m: &mut MakerOrderInfo| { &mut m.base },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MakerOrderInfo>(
                    "MakerOrderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MakerOrderInfo {
        static mut instance: ::protobuf::lazy::Lazy<MakerOrderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MakerOrderInfo,
        };
        unsafe {
            instance.get(MakerOrderInfo::new)
        }
    }
}

impl ::protobuf::Clear for MakerOrderInfo {
    fn clear(&mut self) {
        self.clear_trade_height();
        self.clear_deposit();
        self.clear_settlement();
        self.clear_shift_maker();
        self.clear_shift_taker();
        self.clear_sends_from_chain();
        self.clear_receives_to_chain();
        self.clear_sends_from_address();
        self.clear_receives_to_address();
        self.clear_sends_unit();
        self.clear_receives_unit();
        self.clear_double_hashed_bc_address();
        self.clear_collateralized_nrg();
        self.clear_nrg_unit();
        self.clear_tx_hash();
        self.clear_tx_output_index();
        self.clear_is_settled();
        self.clear_fixed_unit_fee();
        self.clear_base();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MakerOrderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MakerOrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TakerOrderInfo {
    // message fields
    pub sends_from_address: ::std::string::String,
    pub receives_to_address: ::std::string::String,
    pub double_hashed_bc_address: ::std::string::String,
    pub is_settled: bool,
    pub tx_hash: ::std::string::String,
    pub tx_output_index: u32,
    pub total_collateral: ::std::string::String,
    pub trade_height: u64,
    pub timestamp: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TakerOrderInfo {
    pub fn new() -> TakerOrderInfo {
        ::std::default::Default::default()
    }

    // string sends_from_address = 1;

    pub fn clear_sends_from_address(&mut self) {
        self.sends_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_from_address(&mut self, v: ::std::string::String) {
        self.sends_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_from_address(&mut self) -> &mut ::std::string::String {
        &mut self.sends_from_address
    }

    // Take field
    pub fn take_sends_from_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_from_address, ::std::string::String::new())
    }

    pub fn get_sends_from_address(&self) -> &str {
        &self.sends_from_address
    }

    // string receives_to_address = 2;

    pub fn clear_receives_to_address(&mut self) {
        self.receives_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives_to_address(&mut self, v: ::std::string::String) {
        self.receives_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receives_to_address(&mut self) -> &mut ::std::string::String {
        &mut self.receives_to_address
    }

    // Take field
    pub fn take_receives_to_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receives_to_address, ::std::string::String::new())
    }

    pub fn get_receives_to_address(&self) -> &str {
        &self.receives_to_address
    }

    // string double_hashed_bc_address = 3;

    pub fn clear_double_hashed_bc_address(&mut self) {
        self.double_hashed_bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_double_hashed_bc_address(&mut self, v: ::std::string::String) {
        self.double_hashed_bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_double_hashed_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.double_hashed_bc_address
    }

    // Take field
    pub fn take_double_hashed_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.double_hashed_bc_address, ::std::string::String::new())
    }

    pub fn get_double_hashed_bc_address(&self) -> &str {
        &self.double_hashed_bc_address
    }

    // bool is_settled = 4;

    pub fn clear_is_settled(&mut self) {
        self.is_settled = false;
    }

    // Param is passed by value, moved
    pub fn set_is_settled(&mut self, v: bool) {
        self.is_settled = v;
    }

    pub fn get_is_settled(&self) -> bool {
        self.is_settled
    }

    // string tx_hash = 5;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // uint32 tx_output_index = 6;

    pub fn clear_tx_output_index(&mut self) {
        self.tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_output_index(&mut self, v: u32) {
        self.tx_output_index = v;
    }

    pub fn get_tx_output_index(&self) -> u32 {
        self.tx_output_index
    }

    // string total_collateral = 7;

    pub fn clear_total_collateral(&mut self) {
        self.total_collateral.clear();
    }

    // Param is passed by value, moved
    pub fn set_total_collateral(&mut self, v: ::std::string::String) {
        self.total_collateral = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_collateral(&mut self) -> &mut ::std::string::String {
        &mut self.total_collateral
    }

    // Take field
    pub fn take_total_collateral(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.total_collateral, ::std::string::String::new())
    }

    pub fn get_total_collateral(&self) -> &str {
        &self.total_collateral
    }

    // uint64 trade_height = 8;

    pub fn clear_trade_height(&mut self) {
        self.trade_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_trade_height(&mut self, v: u64) {
        self.trade_height = v;
    }

    pub fn get_trade_height(&self) -> u64 {
        self.trade_height
    }

    // uint64 timestamp = 9;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
}

impl ::protobuf::Message for TakerOrderInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_from_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receives_to_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.double_hashed_bc_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_settled = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tx_output_index = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.total_collateral)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trade_height = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sends_from_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sends_from_address);
        }
        if !self.receives_to_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receives_to_address);
        }
        if !self.double_hashed_bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.double_hashed_bc_address);
        }
        if self.is_settled != false {
            my_size += 2;
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tx_hash);
        }
        if self.tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(6, self.tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.total_collateral.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.total_collateral);
        }
        if self.trade_height != 0 {
            my_size += ::protobuf::rt::value_size(8, self.trade_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sends_from_address.is_empty() {
            os.write_string(1, &self.sends_from_address)?;
        }
        if !self.receives_to_address.is_empty() {
            os.write_string(2, &self.receives_to_address)?;
        }
        if !self.double_hashed_bc_address.is_empty() {
            os.write_string(3, &self.double_hashed_bc_address)?;
        }
        if self.is_settled != false {
            os.write_bool(4, self.is_settled)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_string(5, &self.tx_hash)?;
        }
        if self.tx_output_index != 0 {
            os.write_uint32(6, self.tx_output_index)?;
        }
        if !self.total_collateral.is_empty() {
            os.write_string(7, &self.total_collateral)?;
        }
        if self.trade_height != 0 {
            os.write_uint64(8, self.trade_height)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(9, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TakerOrderInfo {
        TakerOrderInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_from_address",
                    |m: &TakerOrderInfo| { &m.sends_from_address },
                    |m: &mut TakerOrderInfo| { &mut m.sends_from_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "receives_to_address",
                    |m: &TakerOrderInfo| { &m.receives_to_address },
                    |m: &mut TakerOrderInfo| { &mut m.receives_to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "double_hashed_bc_address",
                    |m: &TakerOrderInfo| { &m.double_hashed_bc_address },
                    |m: &mut TakerOrderInfo| { &mut m.double_hashed_bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_settled",
                    |m: &TakerOrderInfo| { &m.is_settled },
                    |m: &mut TakerOrderInfo| { &mut m.is_settled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &TakerOrderInfo| { &m.tx_hash },
                    |m: &mut TakerOrderInfo| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tx_output_index",
                    |m: &TakerOrderInfo| { &m.tx_output_index },
                    |m: &mut TakerOrderInfo| { &mut m.tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "total_collateral",
                    |m: &TakerOrderInfo| { &m.total_collateral },
                    |m: &mut TakerOrderInfo| { &mut m.total_collateral },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "trade_height",
                    |m: &TakerOrderInfo| { &m.trade_height },
                    |m: &mut TakerOrderInfo| { &mut m.trade_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &TakerOrderInfo| { &m.timestamp },
                    |m: &mut TakerOrderInfo| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TakerOrderInfo>(
                    "TakerOrderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TakerOrderInfo {
        static mut instance: ::protobuf::lazy::Lazy<TakerOrderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TakerOrderInfo,
        };
        unsafe {
            instance.get(TakerOrderInfo::new)
        }
    }
}

impl ::protobuf::Clear for TakerOrderInfo {
    fn clear(&mut self) {
        self.clear_sends_from_address();
        self.clear_receives_to_address();
        self.clear_double_hashed_bc_address();
        self.clear_is_settled();
        self.clear_tx_hash();
        self.clear_tx_output_index();
        self.clear_total_collateral();
        self.clear_trade_height();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TakerOrderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TakerOrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchedOrderInfo {
    // message fields
    pub maker: ::protobuf::SingularPtrField<MakerOrderInfo>,
    pub taker: ::protobuf::SingularPtrField<TakerOrderInfo>,
    pub unlocked: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MatchedOrderInfo {
    pub fn new() -> MatchedOrderInfo {
        ::std::default::Default::default()
    }

    // .bc.MakerOrderInfo maker = 1;

    pub fn clear_maker(&mut self) {
        self.maker.clear();
    }

    pub fn has_maker(&self) -> bool {
        self.maker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maker(&mut self, v: MakerOrderInfo) {
        self.maker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker(&mut self) -> &mut MakerOrderInfo {
        if self.maker.is_none() {
            self.maker.set_default();
        }
        self.maker.as_mut().unwrap()
    }

    // Take field
    pub fn take_maker(&mut self) -> MakerOrderInfo {
        self.maker.take().unwrap_or_else(|| MakerOrderInfo::new())
    }

    pub fn get_maker(&self) -> &MakerOrderInfo {
        self.maker.as_ref().unwrap_or_else(|| MakerOrderInfo::default_instance())
    }

    // .bc.TakerOrderInfo taker = 2;

    pub fn clear_taker(&mut self) {
        self.taker.clear();
    }

    pub fn has_taker(&self) -> bool {
        self.taker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taker(&mut self, v: TakerOrderInfo) {
        self.taker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_taker(&mut self) -> &mut TakerOrderInfo {
        if self.taker.is_none() {
            self.taker.set_default();
        }
        self.taker.as_mut().unwrap()
    }

    // Take field
    pub fn take_taker(&mut self) -> TakerOrderInfo {
        self.taker.take().unwrap_or_else(|| TakerOrderInfo::new())
    }

    pub fn get_taker(&self) -> &TakerOrderInfo {
        self.taker.as_ref().unwrap_or_else(|| TakerOrderInfo::default_instance())
    }

    // bool unlocked = 7;

    pub fn clear_unlocked(&mut self) {
        self.unlocked = false;
    }

    // Param is passed by value, moved
    pub fn set_unlocked(&mut self, v: bool) {
        self.unlocked = v;
    }

    pub fn get_unlocked(&self) -> bool {
        self.unlocked
    }
}

impl ::protobuf::Message for MatchedOrderInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.maker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.taker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.taker)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unlocked = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.maker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.taker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unlocked != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.maker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.taker.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unlocked != false {
            os.write_bool(7, self.unlocked)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchedOrderInfo {
        MatchedOrderInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MakerOrderInfo>>(
                    "maker",
                    |m: &MatchedOrderInfo| { &m.maker },
                    |m: &mut MatchedOrderInfo| { &mut m.maker },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TakerOrderInfo>>(
                    "taker",
                    |m: &MatchedOrderInfo| { &m.taker },
                    |m: &mut MatchedOrderInfo| { &mut m.taker },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unlocked",
                    |m: &MatchedOrderInfo| { &m.unlocked },
                    |m: &mut MatchedOrderInfo| { &mut m.unlocked },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchedOrderInfo>(
                    "MatchedOrderInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchedOrderInfo {
        static mut instance: ::protobuf::lazy::Lazy<MatchedOrderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchedOrderInfo,
        };
        unsafe {
            instance.get(MatchedOrderInfo::new)
        }
    }
}

impl ::protobuf::Clear for MatchedOrderInfo {
    fn clear(&mut self) {
        self.clear_maker();
        self.clear_taker();
        self.clear_unlocked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchedOrderInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchedOrderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOpenOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<MakerOrderInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOpenOrdersResponse {
    pub fn new() -> GetOpenOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.MakerOrderInfo orders = 1;

    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<MakerOrderInfo>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<MakerOrderInfo> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<MakerOrderInfo> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    pub fn get_orders(&self) -> &[MakerOrderInfo] {
        &self.orders
    }
}

impl ::protobuf::Message for GetOpenOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOpenOrdersResponse {
        GetOpenOrdersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MakerOrderInfo>>(
                    "orders",
                    |m: &GetOpenOrdersResponse| { &m.orders },
                    |m: &mut GetOpenOrdersResponse| { &mut m.orders },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOpenOrdersResponse>(
                    "GetOpenOrdersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOpenOrdersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetOpenOrdersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOpenOrdersResponse,
        };
        unsafe {
            instance.get(GetOpenOrdersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetOpenOrdersResponse {
    fn clear(&mut self) {
        self.clear_orders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOpenOrdersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOpenOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMatchedOrdersResponse {
    // message fields
    pub orders: ::protobuf::RepeatedField<MatchedOrderInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetMatchedOrdersResponse {
    pub fn new() -> GetMatchedOrdersResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.MatchedOrderInfo orders = 1;

    pub fn clear_orders(&mut self) {
        self.orders.clear();
    }

    // Param is passed by value, moved
    pub fn set_orders(&mut self, v: ::protobuf::RepeatedField<MatchedOrderInfo>) {
        self.orders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_orders(&mut self) -> &mut ::protobuf::RepeatedField<MatchedOrderInfo> {
        &mut self.orders
    }

    // Take field
    pub fn take_orders(&mut self) -> ::protobuf::RepeatedField<MatchedOrderInfo> {
        ::std::mem::replace(&mut self.orders, ::protobuf::RepeatedField::new())
    }

    pub fn get_orders(&self) -> &[MatchedOrderInfo] {
        &self.orders
    }
}

impl ::protobuf::Message for GetMatchedOrdersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.orders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.orders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.orders {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMatchedOrdersResponse {
        GetMatchedOrdersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchedOrderInfo>>(
                    "orders",
                    |m: &GetMatchedOrdersResponse| { &m.orders },
                    |m: &mut GetMatchedOrdersResponse| { &mut m.orders },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetMatchedOrdersResponse>(
                    "GetMatchedOrdersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMatchedOrdersResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetMatchedOrdersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetMatchedOrdersResponse,
        };
        unsafe {
            instance.get(GetMatchedOrdersResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetMatchedOrdersResponse {
    fn clear(&mut self) {
        self.clear_orders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMatchedOrdersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMatchedOrdersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TakerOrder {
    // message fields
    pub sends_from_address: ::std::string::String,
    pub receives_to_address: ::std::string::String,
    pub maker_tx_hash: ::std::string::String,
    pub maker_tx_output_index: u32,
    pub collateralized_nrg: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TakerOrder {
    pub fn new() -> TakerOrder {
        ::std::default::Default::default()
    }

    // string sends_from_address = 1;

    pub fn clear_sends_from_address(&mut self) {
        self.sends_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_sends_from_address(&mut self, v: ::std::string::String) {
        self.sends_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sends_from_address(&mut self) -> &mut ::std::string::String {
        &mut self.sends_from_address
    }

    // Take field
    pub fn take_sends_from_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sends_from_address, ::std::string::String::new())
    }

    pub fn get_sends_from_address(&self) -> &str {
        &self.sends_from_address
    }

    // string receives_to_address = 2;

    pub fn clear_receives_to_address(&mut self) {
        self.receives_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receives_to_address(&mut self, v: ::std::string::String) {
        self.receives_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receives_to_address(&mut self) -> &mut ::std::string::String {
        &mut self.receives_to_address
    }

    // Take field
    pub fn take_receives_to_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.receives_to_address, ::std::string::String::new())
    }

    pub fn get_receives_to_address(&self) -> &str {
        &self.receives_to_address
    }

    // string maker_tx_hash = 3;

    pub fn clear_maker_tx_hash(&mut self) {
        self.maker_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_hash(&mut self, v: ::std::string::String) {
        self.maker_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maker_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.maker_tx_hash
    }

    // Take field
    pub fn take_maker_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.maker_tx_hash, ::std::string::String::new())
    }

    pub fn get_maker_tx_hash(&self) -> &str {
        &self.maker_tx_hash
    }

    // uint32 maker_tx_output_index = 4;

    pub fn clear_maker_tx_output_index(&mut self) {
        self.maker_tx_output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_maker_tx_output_index(&mut self, v: u32) {
        self.maker_tx_output_index = v;
    }

    pub fn get_maker_tx_output_index(&self) -> u32 {
        self.maker_tx_output_index
    }

    // string collateralized_nrg = 5;

    pub fn clear_collateralized_nrg(&mut self) {
        self.collateralized_nrg.clear();
    }

    // Param is passed by value, moved
    pub fn set_collateralized_nrg(&mut self, v: ::std::string::String) {
        self.collateralized_nrg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collateralized_nrg(&mut self) -> &mut ::std::string::String {
        &mut self.collateralized_nrg
    }

    // Take field
    pub fn take_collateralized_nrg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collateralized_nrg, ::std::string::String::new())
    }

    pub fn get_collateralized_nrg(&self) -> &str {
        &self.collateralized_nrg
    }
}

impl ::protobuf::Message for TakerOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sends_from_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.receives_to_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.maker_tx_hash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maker_tx_output_index = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collateralized_nrg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sends_from_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sends_from_address);
        }
        if !self.receives_to_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.receives_to_address);
        }
        if !self.maker_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.maker_tx_hash);
        }
        if self.maker_tx_output_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maker_tx_output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.collateralized_nrg.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.collateralized_nrg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sends_from_address.is_empty() {
            os.write_string(1, &self.sends_from_address)?;
        }
        if !self.receives_to_address.is_empty() {
            os.write_string(2, &self.receives_to_address)?;
        }
        if !self.maker_tx_hash.is_empty() {
            os.write_string(3, &self.maker_tx_hash)?;
        }
        if self.maker_tx_output_index != 0 {
            os.write_uint32(4, self.maker_tx_output_index)?;
        }
        if !self.collateralized_nrg.is_empty() {
            os.write_string(5, &self.collateralized_nrg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TakerOrder {
        TakerOrder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sends_from_address",
                    |m: &TakerOrder| { &m.sends_from_address },
                    |m: &mut TakerOrder| { &mut m.sends_from_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "receives_to_address",
                    |m: &TakerOrder| { &m.receives_to_address },
                    |m: &mut TakerOrder| { &mut m.receives_to_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "maker_tx_hash",
                    |m: &TakerOrder| { &m.maker_tx_hash },
                    |m: &mut TakerOrder| { &mut m.maker_tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maker_tx_output_index",
                    |m: &TakerOrder| { &m.maker_tx_output_index },
                    |m: &mut TakerOrder| { &mut m.maker_tx_output_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collateralized_nrg",
                    |m: &TakerOrder| { &m.collateralized_nrg },
                    |m: &mut TakerOrder| { &mut m.collateralized_nrg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TakerOrder>(
                    "TakerOrder",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TakerOrder {
        static mut instance: ::protobuf::lazy::Lazy<TakerOrder> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TakerOrder,
        };
        unsafe {
            instance.get(TakerOrder::new)
        }
    }
}

impl ::protobuf::Clear for TakerOrder {
    fn clear(&mut self) {
        self.clear_sends_from_address();
        self.clear_receives_to_address();
        self.clear_maker_tx_hash();
        self.clear_maker_tx_output_index();
        self.clear_collateralized_nrg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TakerOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TakerOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlake2blRequest {
    // message fields
    pub to_be_hashed: ::std::string::String,
    pub times: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlake2blRequest {
    pub fn new() -> GetBlake2blRequest {
        ::std::default::Default::default()
    }

    // string to_be_hashed = 1;

    pub fn clear_to_be_hashed(&mut self) {
        self.to_be_hashed.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_be_hashed(&mut self, v: ::std::string::String) {
        self.to_be_hashed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_be_hashed(&mut self) -> &mut ::std::string::String {
        &mut self.to_be_hashed
    }

    // Take field
    pub fn take_to_be_hashed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to_be_hashed, ::std::string::String::new())
    }

    pub fn get_to_be_hashed(&self) -> &str {
        &self.to_be_hashed
    }

    // uint32 times = 2;

    pub fn clear_times(&mut self) {
        self.times = 0;
    }

    // Param is passed by value, moved
    pub fn set_times(&mut self, v: u32) {
        self.times = v;
    }

    pub fn get_times(&self) -> u32 {
        self.times
    }
}

impl ::protobuf::Message for GetBlake2blRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to_be_hashed)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.times = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.to_be_hashed.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.to_be_hashed);
        }
        if self.times != 0 {
            my_size += ::protobuf::rt::value_size(2, self.times, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.to_be_hashed.is_empty() {
            os.write_string(1, &self.to_be_hashed)?;
        }
        if self.times != 0 {
            os.write_uint32(2, self.times)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlake2blRequest {
        GetBlake2blRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to_be_hashed",
                    |m: &GetBlake2blRequest| { &m.to_be_hashed },
                    |m: &mut GetBlake2blRequest| { &mut m.to_be_hashed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "times",
                    |m: &GetBlake2blRequest| { &m.times },
                    |m: &mut GetBlake2blRequest| { &mut m.times },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlake2blRequest>(
                    "GetBlake2blRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlake2blRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlake2blRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlake2blRequest,
        };
        unsafe {
            instance.get(GetBlake2blRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBlake2blRequest {
    fn clear(&mut self) {
        self.clear_to_be_hashed();
        self.clear_times();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlake2blRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlake2blRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlake2blResponse {
    // message fields
    pub hash: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlake2blResponse {
    pub fn new() -> GetBlake2blResponse {
        ::std::default::Default::default()
    }

    // string hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

impl ::protobuf::Message for GetBlake2blResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlake2blResponse {
        GetBlake2blResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetBlake2blResponse| { &m.hash },
                    |m: &mut GetBlake2blResponse| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlake2blResponse>(
                    "GetBlake2blResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlake2blResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBlake2blResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlake2blResponse,
        };
        unsafe {
            instance.get(GetBlake2blResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBlake2blResponse {
    fn clear(&mut self) {
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlake2blResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlake2blResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VanityConvertRequest {
    // message fields
    pub vanity: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VanityConvertRequest {
    pub fn new() -> VanityConvertRequest {
        ::std::default::Default::default()
    }

    // string vanity = 1;

    pub fn clear_vanity(&mut self) {
        self.vanity.clear();
    }

    // Param is passed by value, moved
    pub fn set_vanity(&mut self, v: ::std::string::String) {
        self.vanity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity(&mut self) -> &mut ::std::string::String {
        &mut self.vanity
    }

    // Take field
    pub fn take_vanity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vanity, ::std::string::String::new())
    }

    pub fn get_vanity(&self) -> &str {
        &self.vanity
    }
}

impl ::protobuf::Message for VanityConvertRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vanity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vanity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.vanity);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.vanity.is_empty() {
            os.write_string(1, &self.vanity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VanityConvertRequest {
        VanityConvertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vanity",
                    |m: &VanityConvertRequest| { &m.vanity },
                    |m: &mut VanityConvertRequest| { &mut m.vanity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VanityConvertRequest>(
                    "VanityConvertRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VanityConvertRequest {
        static mut instance: ::protobuf::lazy::Lazy<VanityConvertRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VanityConvertRequest,
        };
        unsafe {
            instance.get(VanityConvertRequest::new)
        }
    }
}

impl ::protobuf::Clear for VanityConvertRequest {
    fn clear(&mut self) {
        self.clear_vanity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VanityConvertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VanityConvertRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VanityConvertResponse {
    // message fields
    pub bc_address: ::std::string::String,
    pub error: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VanityConvertResponse {
    pub fn new() -> VanityConvertResponse {
        ::std::default::Default::default()
    }

    // string bc_address = 1;

    pub fn clear_bc_address(&mut self) {
        self.bc_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_bc_address(&mut self, v: ::std::string::String) {
        self.bc_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bc_address(&mut self) -> &mut ::std::string::String {
        &mut self.bc_address
    }

    // Take field
    pub fn take_bc_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bc_address, ::std::string::String::new())
    }

    pub fn get_bc_address(&self) -> &str {
        &self.bc_address
    }

    // string error = 2;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }
}

impl ::protobuf::Message for VanityConvertResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bc_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bc_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bc_address);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.bc_address.is_empty() {
            os.write_string(1, &self.bc_address)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VanityConvertResponse {
        VanityConvertResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bc_address",
                    |m: &VanityConvertResponse| { &m.bc_address },
                    |m: &mut VanityConvertResponse| { &mut m.bc_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &VanityConvertResponse| { &m.error },
                    |m: &mut VanityConvertResponse| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VanityConvertResponse>(
                    "VanityConvertResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VanityConvertResponse {
        static mut instance: ::protobuf::lazy::Lazy<VanityConvertResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VanityConvertResponse,
        };
        unsafe {
            instance.get(VanityConvertResponse::new)
        }
    }
}

impl ::protobuf::Clear for VanityConvertResponse {
    fn clear(&mut self) {
        self.clear_bc_address();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VanityConvertResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VanityConvertResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRoveredBlockHashRequest {
    // message fields
    pub blockchain: ::std::string::String,
    pub hash: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetRoveredBlockHashRequest {
    pub fn new() -> GetRoveredBlockHashRequest {
        ::std::default::Default::default()
    }

    // string blockchain = 1;

    pub fn clear_blockchain(&mut self) {
        self.blockchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockchain(&mut self, v: ::std::string::String) {
        self.blockchain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockchain(&mut self) -> &mut ::std::string::String {
        &mut self.blockchain
    }

    // Take field
    pub fn take_blockchain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blockchain, ::std::string::String::new())
    }

    pub fn get_blockchain(&self) -> &str {
        &self.blockchain
    }

    // string hash = 2;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

impl ::protobuf::Message for GetRoveredBlockHashRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blockchain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockchain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.blockchain);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockchain.is_empty() {
            os.write_string(1, &self.blockchain)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRoveredBlockHashRequest {
        GetRoveredBlockHashRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockchain",
                    |m: &GetRoveredBlockHashRequest| { &m.blockchain },
                    |m: &mut GetRoveredBlockHashRequest| { &mut m.blockchain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetRoveredBlockHashRequest| { &m.hash },
                    |m: &mut GetRoveredBlockHashRequest| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRoveredBlockHashRequest>(
                    "GetRoveredBlockHashRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRoveredBlockHashRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetRoveredBlockHashRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRoveredBlockHashRequest,
        };
        unsafe {
            instance.get(GetRoveredBlockHashRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetRoveredBlockHashRequest {
    fn clear(&mut self) {
        self.clear_blockchain();
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRoveredBlockHashRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRoveredBlockHashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRoveredBlockHeightRequest {
    // message fields
    pub blockchain: ::std::string::String,
    pub height: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetRoveredBlockHeightRequest {
    pub fn new() -> GetRoveredBlockHeightRequest {
        ::std::default::Default::default()
    }

    // string blockchain = 1;

    pub fn clear_blockchain(&mut self) {
        self.blockchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockchain(&mut self, v: ::std::string::String) {
        self.blockchain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockchain(&mut self) -> &mut ::std::string::String {
        &mut self.blockchain
    }

    // Take field
    pub fn take_blockchain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blockchain, ::std::string::String::new())
    }

    pub fn get_blockchain(&self) -> &str {
        &self.blockchain
    }

    // uint32 height = 2;

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = v;
    }

    pub fn get_height(&self) -> u32 {
        self.height
    }
}

impl ::protobuf::Message for GetRoveredBlockHeightRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blockchain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockchain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.blockchain);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockchain.is_empty() {
            os.write_string(1, &self.blockchain)?;
        }
        if self.height != 0 {
            os.write_uint32(2, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRoveredBlockHeightRequest {
        GetRoveredBlockHeightRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockchain",
                    |m: &GetRoveredBlockHeightRequest| { &m.blockchain },
                    |m: &mut GetRoveredBlockHeightRequest| { &mut m.blockchain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &GetRoveredBlockHeightRequest| { &m.height },
                    |m: &mut GetRoveredBlockHeightRequest| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRoveredBlockHeightRequest>(
                    "GetRoveredBlockHeightRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRoveredBlockHeightRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetRoveredBlockHeightRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRoveredBlockHeightRequest,
        };
        unsafe {
            instance.get(GetRoveredBlockHeightRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetRoveredBlockHeightRequest {
    fn clear(&mut self) {
        self.clear_blockchain();
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRoveredBlockHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRoveredBlockHeightRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockHashRequest {
    // message fields
    pub hash: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlockHashRequest {
    pub fn new() -> GetBlockHashRequest {
        ::std::default::Default::default()
    }

    // string hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

impl ::protobuf::Message for GetBlockHashRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockHashRequest {
        GetBlockHashRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetBlockHashRequest| { &m.hash },
                    |m: &mut GetBlockHashRequest| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockHashRequest>(
                    "GetBlockHashRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockHashRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockHashRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockHashRequest,
        };
        unsafe {
            instance.get(GetBlockHashRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockHashRequest {
    fn clear(&mut self) {
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockHashRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockHashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockHeightRequest {
    // message fields
    pub height: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlockHeightRequest {
    pub fn new() -> GetBlockHeightRequest {
        ::std::default::Default::default()
    }

    // uint32 height = 1;

    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = v;
    }

    pub fn get_height(&self) -> u32 {
        self.height
    }
}

impl ::protobuf::Message for GetBlockHeightRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_uint32(1, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockHeightRequest {
        GetBlockHeightRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "height",
                    |m: &GetBlockHeightRequest| { &m.height },
                    |m: &mut GetBlockHeightRequest| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockHeightRequest>(
                    "GetBlockHeightRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockHeightRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockHeightRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockHeightRequest,
        };
        unsafe {
            instance.get(GetBlockHeightRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockHeightRequest {
    fn clear(&mut self) {
        self.clear_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockHeightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockHeightRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksRequest {
    // message fields
    pub start_height: u32,
    pub end_height: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksRequest {
    pub fn new() -> GetBlocksRequest {
        ::std::default::Default::default()
    }

    // uint32 start_height = 1;

    pub fn clear_start_height(&mut self) {
        self.start_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_height(&mut self, v: u32) {
        self.start_height = v;
    }

    pub fn get_start_height(&self) -> u32 {
        self.start_height
    }

    // uint32 end_height = 2;

    pub fn clear_end_height(&mut self) {
        self.end_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_height(&mut self, v: u32) {
        self.end_height = v;
    }

    pub fn get_end_height(&self) -> u32 {
        self.end_height
    }
}

impl ::protobuf::Message for GetBlocksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_height != 0 {
            os.write_uint32(1, self.start_height)?;
        }
        if self.end_height != 0 {
            os.write_uint32(2, self.end_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksRequest {
        GetBlocksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_height",
                    |m: &GetBlocksRequest| { &m.start_height },
                    |m: &mut GetBlocksRequest| { &mut m.start_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_height",
                    |m: &GetBlocksRequest| { &m.end_height },
                    |m: &mut GetBlocksRequest| { &mut m.end_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksRequest>(
                    "GetBlocksRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksRequest,
        };
        unsafe {
            instance.get(GetBlocksRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksRequest {
    fn clear(&mut self) {
        self.clear_start_height();
        self.clear_end_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlocksResponse {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::core::BcBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetBlocksResponse {
    pub fn new() -> GetBlocksResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.BcBlock blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::core::BcBlock>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::core::BcBlock> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::core::BcBlock> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::core::BcBlock] {
        &self.blocks
    }
}

impl ::protobuf::Message for GetBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlocksResponse {
        GetBlocksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::core::BcBlock>>(
                    "blocks",
                    |m: &GetBlocksResponse| { &m.blocks },
                    |m: &mut GetBlocksResponse| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlocksResponse>(
                    "GetBlocksResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlocksResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBlocksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlocksResponse,
        };
        unsafe {
            instance.get(GetBlocksResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBlocksResponse {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlocksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRoveredBlocksRequest {
    // message fields
    pub blockchain: ::std::string::String,
    pub start_height: u32,
    pub end_height: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetRoveredBlocksRequest {
    pub fn new() -> GetRoveredBlocksRequest {
        ::std::default::Default::default()
    }

    // string blockchain = 1;

    pub fn clear_blockchain(&mut self) {
        self.blockchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockchain(&mut self, v: ::std::string::String) {
        self.blockchain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockchain(&mut self) -> &mut ::std::string::String {
        &mut self.blockchain
    }

    // Take field
    pub fn take_blockchain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blockchain, ::std::string::String::new())
    }

    pub fn get_blockchain(&self) -> &str {
        &self.blockchain
    }

    // uint32 start_height = 2;

    pub fn clear_start_height(&mut self) {
        self.start_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_height(&mut self, v: u32) {
        self.start_height = v;
    }

    pub fn get_start_height(&self) -> u32 {
        self.start_height
    }

    // uint32 end_height = 3;

    pub fn clear_end_height(&mut self) {
        self.end_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_height(&mut self, v: u32) {
        self.end_height = v;
    }

    pub fn get_end_height(&self) -> u32 {
        self.end_height
    }
}

impl ::protobuf::Message for GetRoveredBlocksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blockchain)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockchain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.blockchain);
        }
        if self.start_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.end_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockchain.is_empty() {
            os.write_string(1, &self.blockchain)?;
        }
        if self.start_height != 0 {
            os.write_uint32(2, self.start_height)?;
        }
        if self.end_height != 0 {
            os.write_uint32(3, self.end_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRoveredBlocksRequest {
        GetRoveredBlocksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockchain",
                    |m: &GetRoveredBlocksRequest| { &m.blockchain },
                    |m: &mut GetRoveredBlocksRequest| { &mut m.blockchain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_height",
                    |m: &GetRoveredBlocksRequest| { &m.start_height },
                    |m: &mut GetRoveredBlocksRequest| { &mut m.start_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_height",
                    |m: &GetRoveredBlocksRequest| { &m.end_height },
                    |m: &mut GetRoveredBlocksRequest| { &mut m.end_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRoveredBlocksRequest>(
                    "GetRoveredBlocksRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRoveredBlocksRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetRoveredBlocksRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRoveredBlocksRequest,
        };
        unsafe {
            instance.get(GetRoveredBlocksRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetRoveredBlocksRequest {
    fn clear(&mut self) {
        self.clear_blockchain();
        self.clear_start_height();
        self.clear_end_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRoveredBlocksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRoveredBlocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRawMempoolResponse {
    // message fields
    pub transactions: ::protobuf::RepeatedField<super::core::Transaction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetRawMempoolResponse {
    pub fn new() -> GetRawMempoolResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.Transaction transactions = 1;

    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<super::core::Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<super::core::Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<super::core::Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    pub fn get_transactions(&self) -> &[super::core::Transaction] {
        &self.transactions
    }
}

impl ::protobuf::Message for GetRawMempoolResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRawMempoolResponse {
        GetRawMempoolResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::core::Transaction>>(
                    "transactions",
                    |m: &GetRawMempoolResponse| { &m.transactions },
                    |m: &mut GetRawMempoolResponse| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRawMempoolResponse>(
                    "GetRawMempoolResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRawMempoolResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetRawMempoolResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRawMempoolResponse,
        };
        unsafe {
            instance.get(GetRawMempoolResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetRawMempoolResponse {
    fn clear(&mut self) {
        self.clear_transactions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRawMempoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRawMempoolResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRoveredBlocksResponse {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::core::Block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetRoveredBlocksResponse {
    pub fn new() -> GetRoveredBlocksResponse {
        ::std::default::Default::default()
    }

    // repeated .bc.Block blocks = 1;

    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::core::Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::core::Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::core::Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blocks(&self) -> &[super::core::Block] {
        &self.blocks
    }
}

impl ::protobuf::Message for GetRoveredBlocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRoveredBlocksResponse {
        GetRoveredBlocksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::core::Block>>(
                    "blocks",
                    |m: &GetRoveredBlocksResponse| { &m.blocks },
                    |m: &mut GetRoveredBlocksResponse| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetRoveredBlocksResponse>(
                    "GetRoveredBlocksResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetRoveredBlocksResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetRoveredBlocksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRoveredBlocksResponse,
        };
        unsafe {
            instance.get(GetRoveredBlocksResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetRoveredBlocksResponse {
    fn clear(&mut self) {
        self.clear_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRoveredBlocksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRoveredBlocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTxRequest {
    // message fields
    pub hash: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTxRequest {
    pub fn new() -> GetTxRequest {
        ::std::default::Default::default()
    }

    // string hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

impl ::protobuf::Message for GetTxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTxRequest {
        GetTxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetTxRequest| { &m.hash },
                    |m: &mut GetTxRequest| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTxRequest>(
                    "GetTxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTxRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTxRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTxRequest,
        };
        unsafe {
            instance.get(GetTxRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTxRequest {
    fn clear(&mut self) {
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMarkedTxRequest {
    // message fields
    pub blockchain: ::std::string::String,
    pub hash: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetMarkedTxRequest {
    pub fn new() -> GetMarkedTxRequest {
        ::std::default::Default::default()
    }

    // string blockchain = 1;

    pub fn clear_blockchain(&mut self) {
        self.blockchain.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockchain(&mut self, v: ::std::string::String) {
        self.blockchain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockchain(&mut self) -> &mut ::std::string::String {
        &mut self.blockchain
    }

    // Take field
    pub fn take_blockchain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blockchain, ::std::string::String::new())
    }

    pub fn get_blockchain(&self) -> &str {
        &self.blockchain
    }

    // string hash = 2;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }
}

impl ::protobuf::Message for GetMarkedTxRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blockchain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockchain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.blockchain);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockchain.is_empty() {
            os.write_string(1, &self.blockchain)?;
        }
        if !self.hash.is_empty() {
            os.write_string(2, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMarkedTxRequest {
        GetMarkedTxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockchain",
                    |m: &GetMarkedTxRequest| { &m.blockchain },
                    |m: &mut GetMarkedTxRequest| { &mut m.blockchain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetMarkedTxRequest| { &m.hash },
                    |m: &mut GetMarkedTxRequest| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetMarkedTxRequest>(
                    "GetMarkedTxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMarkedTxRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetMarkedTxRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetMarkedTxRequest,
        };
        unsafe {
            instance.get(GetMarkedTxRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetMarkedTxRequest {
    fn clear(&mut self) {
        self.clear_blockchain();
        self.clear_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMarkedTxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMarkedTxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOutPointRequest {
    // message fields
    pub hash: ::std::string::String,
    pub index: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOutPointRequest {
    pub fn new() -> GetOutPointRequest {
        ::std::default::Default::default()
    }

    // string hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    pub fn get_hash(&self) -> &str {
        &self.hash
    }

    // uint32 index = 2;

    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    pub fn get_index(&self) -> u32 {
        self.index
    }
}

impl ::protobuf::Message for GetOutPointRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        if self.index != 0 {
            os.write_uint32(2, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOutPointRequest {
        GetOutPointRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hash",
                    |m: &GetOutPointRequest| { &m.hash },
                    |m: &mut GetOutPointRequest| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index",
                    |m: &GetOutPointRequest| { &m.index },
                    |m: &mut GetOutPointRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOutPointRequest>(
                    "GetOutPointRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOutPointRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetOutPointRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOutPointRequest,
        };
        unsafe {
            instance.get(GetOutPointRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetOutPointRequest {
    fn clear(&mut self) {
        self.clear_hash();
        self.clear_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOutPointRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOutPointRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTradeStatusResponse {
    // message fields
    pub status: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTradeStatusResponse {
    pub fn new() -> GetTradeStatusResponse {
        ::std::default::Default::default()
    }

    // uint32 status = 1;

    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = v;
    }

    pub fn get_status(&self) -> u32 {
        self.status
    }
}

impl ::protobuf::Message for GetTradeStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_uint32(1, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTradeStatusResponse {
        GetTradeStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status",
                    |m: &GetTradeStatusResponse| { &m.status },
                    |m: &mut GetTradeStatusResponse| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTradeStatusResponse>(
                    "GetTradeStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTradeStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetTradeStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTradeStatusResponse,
        };
        unsafe {
            instance.get(GetTradeStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetTradeStatusResponse {
    fn clear(&mut self) {
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTradeStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTradeStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOutPointStatusResponse {
    // message fields
    pub unspent: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOutPointStatusResponse {
    pub fn new() -> GetOutPointStatusResponse {
        ::std::default::Default::default()
    }

    // bool unspent = 1;

    pub fn clear_unspent(&mut self) {
        self.unspent = false;
    }

    // Param is passed by value, moved
    pub fn set_unspent(&mut self, v: bool) {
        self.unspent = v;
    }

    pub fn get_unspent(&self) -> bool {
        self.unspent
    }
}

impl ::protobuf::Message for GetOutPointStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unspent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.unspent != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.unspent != false {
            os.write_bool(1, self.unspent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOutPointStatusResponse {
        GetOutPointStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unspent",
                    |m: &GetOutPointStatusResponse| { &m.unspent },
                    |m: &mut GetOutPointStatusResponse| { &mut m.unspent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOutPointStatusResponse>(
                    "GetOutPointStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOutPointStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetOutPointStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOutPointStatusResponse,
        };
        unsafe {
            instance.get(GetOutPointStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetOutPointStatusResponse {
    fn clear(&mut self) {
        self.clear_unspent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOutPointStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOutPointStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CurrentWork {
    // message fields
    pub work: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CurrentWork {
    pub fn new() -> CurrentWork {
        ::std::default::Default::default()
    }

    // string work = 1;

    pub fn clear_work(&mut self) {
        self.work.clear();
    }

    // Param is passed by value, moved
    pub fn set_work(&mut self, v: ::std::string::String) {
        self.work = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_work(&mut self) -> &mut ::std::string::String {
        &mut self.work
    }

    // Take field
    pub fn take_work(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.work, ::std::string::String::new())
    }

    pub fn get_work(&self) -> &str {
        &self.work
    }
}

impl ::protobuf::Message for CurrentWork {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.work)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.work.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.work);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.work.is_empty() {
            os.write_string(1, &self.work)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CurrentWork {
        CurrentWork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "work",
                    |m: &CurrentWork| { &m.work },
                    |m: &mut CurrentWork| { &mut m.work },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CurrentWork>(
                    "CurrentWork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CurrentWork {
        static mut instance: ::protobuf::lazy::Lazy<CurrentWork> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CurrentWork,
        };
        unsafe {
            instance.get(CurrentWork::new)
        }
    }
}

impl ::protobuf::Clear for CurrentWork {
    fn clear(&mut self) {
        self.clear_work();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CurrentWork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CurrentWork {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RpcTransactionResponseStatus {
    Success = 0,
    Failure = 1,
}

impl ::protobuf::ProtobufEnum for RpcTransactionResponseStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RpcTransactionResponseStatus> {
        match value {
            0 => ::std::option::Option::Some(RpcTransactionResponseStatus::Success),
            1 => ::std::option::Option::Some(RpcTransactionResponseStatus::Failure),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RpcTransactionResponseStatus] = &[
            RpcTransactionResponseStatus::Success,
            RpcTransactionResponseStatus::Failure,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RpcTransactionResponseStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RpcTransactionResponseStatus {
}

impl ::std::default::Default for RpcTransactionResponseStatus {
    fn default() -> Self {
        RpcTransactionResponseStatus::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcTransactionResponseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08bc.proto\x12\x02bc\x1a\ncore.proto\"+\n\x0cHelpResponse\x12\x1b\n\
    \thelp_text\x18\x01\x20\x01(\tR\x08helpText\"%\n\rStatsResponse\x12\x14\
    \n\x05calls\x18\x01\x20\x01(\x03R\x05calls\"\x9d\x01\n\x0eRpcTransaction\
    \x12\x1b\n\tfrom_addr\x18\x01\x20\x01(\tR\x08fromAddr\x12\x17\n\x07to_ad\
    dr\x18\x02\x20\x01(\tR\x06toAddr\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\
    \x06amount\x12\x15\n\x06tx_fee\x18\x04\x20\x01(\tR\x05txFee\x12&\n\x0fpr\
    ivate_key_hex\x18\x05\x20\x01(\tR\rprivateKeyHex\"\x81\x01\n\x16RpcTrans\
    actionResponse\x128\n\x06status\x18\x01\x20\x01(\x0e2\x20.bc.RpcTransact\
    ionResponseStatusR\x06status\x12\x17\n\x07tx_hash\x18\x02\x20\x01(\tR\
    \x06txHash\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\"\xbd\x01\n\
    \x08Transfer\x12\x12\n\x04from\x18\x01\x20\x01(\tR\x04from\x12\x0e\n\x02\
    to\x18\x02\x20\x01(\tR\x02to\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\x06\
    amount\x12\x17\n\x07tx_hash\x18\x04\x20\x01(\tR\x06txHash\x12&\n\x0ftx_o\
    utput_index\x18\x05\x20\x01(\rR\rtxOutputIndex\x12\x1c\n\ttimestamp\x18\
    \x06\x20\x01(\x04R\ttimestamp\x12\x16\n\x06height\x18\x07\x20\x01(\x04R\
    \x06height\"+\n\x0fTransferRequest\x12\x18\n\x07address\x18\x01\x20\x01(\
    \tR\x07address\">\n\x10TransferResponse\x12*\n\ttransfers\x18\x01\x20\
    \x03(\x0b2\x0c.bc.TransferR\ttransfers\"7\n\x14GetUtxoLengthRequest\x12\
    \x1f\n\x0bscript_type\x18\x01\x20\x01(\tR\nscriptType\"/\n\x15GetUtxoLen\
    gthResponse\x12\x16\n\x06length\x18\x01\x20\x01(\rR\x06length\"9\n\x1dGe\
    tSpendableCollateralRequest\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07\
    address\"L\n\x1eGetSpendableCollateralResponse\x12*\n\toutpoints\x18\x01\
    \x20\x03(\x0b2\x0c.bc.OutPointR\toutpoints\"-\n\x11GetBalanceRequest\x12\
    \x18\n\x07address\x18\x01\x20\x01(\tR\x07address\"\x9c\x01\n\x12GetBalan\
    ceResponse\x12\x1c\n\tconfirmed\x18\x01\x20\x01(\tR\tconfirmed\x12\x20\n\
    \x0bunconfirmed\x18\x02\x20\x01(\tR\x0bunconfirmed\x12&\n\x0ecollaterali\
    zed\x18\x03\x20\x01(\tR\x0ecollateralized\x12\x1e\n\nunlockable\x18\x04\
    \x20\x01(\tR\nunlockable\"`\n\x1dGetUnlockTakerTxParamsRequest\x12\x17\n\
    \x07tx_hash\x18\x01\x20\x01(\tR\x06txHash\x12&\n\x0ftx_output_index\x18\
    \x02\x20\x01(\rR\rtxOutputIndex\"g\n\x1eGetUnlockTakerTxParamsResponse\
    \x12%\n\x0eunlock_scripts\x18\x01\x20\x03(\tR\runlockScripts\x12\x1e\n\
    \x0bvalue_in_tx\x18\x02\x20\x01(\x0cR\tvalueInTx\"\xc4\x05\n\x0eMakerOrd\
    erInfo\x12!\n\x0ctrade_height\x18\x01\x20\x01(\x04R\x0btradeHeight\x12\
    \x18\n\x07deposit\x18\x02\x20\x01(\x04R\x07deposit\x12\x1e\n\nsettlement\
    \x18\x03\x20\x01(\x04R\nsettlement\x12\x1f\n\x0bshift_maker\x18\x04\x20\
    \x01(\x04R\nshiftMaker\x12\x1f\n\x0bshift_taker\x18\x05\x20\x01(\x04R\ns\
    hiftTaker\x12(\n\x10sends_from_chain\x18\x06\x20\x01(\tR\x0esendsFromCha\
    in\x12*\n\x11receives_to_chain\x18\x07\x20\x01(\tR\x0freceivesToChain\
    \x12,\n\x12sends_from_address\x18\x08\x20\x01(\tR\x10sendsFromAddress\
    \x12.\n\x13receives_to_address\x18\t\x20\x01(\tR\x11receivesToAddress\
    \x12\x1d\n\nsends_unit\x18\n\x20\x01(\tR\tsendsUnit\x12#\n\rreceives_uni\
    t\x18\x0b\x20\x01(\tR\x0creceivesUnit\x127\n\x18double_hashed_bc_address\
    \x18\x0c\x20\x01(\tR\x15doubleHashedBcAddress\x12-\n\x12collateralized_n\
    rg\x18\r\x20\x01(\tR\x11collateralizedNrg\x12\x19\n\x08nrg_unit\x18\x0e\
    \x20\x01(\tR\x07nrgUnit\x12\x17\n\x07tx_hash\x18\x0f\x20\x01(\tR\x06txHa\
    sh\x12&\n\x0ftx_output_index\x18\x10\x20\x01(\rR\rtxOutputIndex\x12\x1d\
    \n\nis_settled\x18\x11\x20\x01(\x08R\tisSettled\x12$\n\x0efixed_unit_fee\
    \x18\x12\x20\x01(\tR\x0cfixedUnitFee\x12\x12\n\x04base\x18\x13\x20\x01(\
    \rR\x04base\"\xf3\x02\n\x0eTakerOrderInfo\x12,\n\x12sends_from_address\
    \x18\x01\x20\x01(\tR\x10sendsFromAddress\x12.\n\x13receives_to_address\
    \x18\x02\x20\x01(\tR\x11receivesToAddress\x127\n\x18double_hashed_bc_add\
    ress\x18\x03\x20\x01(\tR\x15doubleHashedBcAddress\x12\x1d\n\nis_settled\
    \x18\x04\x20\x01(\x08R\tisSettled\x12\x17\n\x07tx_hash\x18\x05\x20\x01(\
    \tR\x06txHash\x12&\n\x0ftx_output_index\x18\x06\x20\x01(\rR\rtxOutputInd\
    ex\x12)\n\x10total_collateral\x18\x07\x20\x01(\tR\x0ftotalCollateral\x12\
    !\n\x0ctrade_height\x18\x08\x20\x01(\x04R\x0btradeHeight\x12\x1c\n\ttime\
    stamp\x18\t\x20\x01(\x04R\ttimestamp\"\x82\x01\n\x10MatchedOrderInfo\x12\
    (\n\x05maker\x18\x01\x20\x01(\x0b2\x12.bc.MakerOrderInfoR\x05maker\x12(\
    \n\x05taker\x18\x02\x20\x01(\x0b2\x12.bc.TakerOrderInfoR\x05taker\x12\
    \x1a\n\x08unlocked\x18\x07\x20\x01(\x08R\x08unlocked\"C\n\x15GetOpenOrde\
    rsResponse\x12*\n\x06orders\x18\x01\x20\x03(\x0b2\x12.bc.MakerOrderInfoR\
    \x06orders\"H\n\x18GetMatchedOrdersResponse\x12,\n\x06orders\x18\x01\x20\
    \x03(\x0b2\x14.bc.MatchedOrderInfoR\x06orders\"\xf0\x01\n\nTakerOrder\
    \x12,\n\x12sends_from_address\x18\x01\x20\x01(\tR\x10sendsFromAddress\
    \x12.\n\x13receives_to_address\x18\x02\x20\x01(\tR\x11receivesToAddress\
    \x12\"\n\rmaker_tx_hash\x18\x03\x20\x01(\tR\x0bmakerTxHash\x121\n\x15mak\
    er_tx_output_index\x18\x04\x20\x01(\rR\x12makerTxOutputIndex\x12-\n\x12c\
    ollateralized_nrg\x18\x05\x20\x01(\tR\x11collateralizedNrg\"L\n\x12GetBl\
    ake2blRequest\x12\x20\n\x0cto_be_hashed\x18\x01\x20\x01(\tR\ntoBeHashed\
    \x12\x14\n\x05times\x18\x02\x20\x01(\rR\x05times\")\n\x13GetBlake2blResp\
    onse\x12\x12\n\x04hash\x18\x01\x20\x01(\tR\x04hash\".\n\x14VanityConvert\
    Request\x12\x16\n\x06vanity\x18\x01\x20\x01(\tR\x06vanity\"L\n\x15Vanity\
    ConvertResponse\x12\x1d\n\nbc_address\x18\x01\x20\x01(\tR\tbcAddress\x12\
    \x14\n\x05error\x18\x02\x20\x01(\tR\x05error\"P\n\x1aGetRoveredBlockHash\
    Request\x12\x1e\n\nblockchain\x18\x01\x20\x01(\tR\nblockchain\x12\x12\n\
    \x04hash\x18\x02\x20\x01(\tR\x04hash\"V\n\x1cGetRoveredBlockHeightReques\
    t\x12\x1e\n\nblockchain\x18\x01\x20\x01(\tR\nblockchain\x12\x16\n\x06hei\
    ght\x18\x02\x20\x01(\rR\x06height\")\n\x13GetBlockHashRequest\x12\x12\n\
    \x04hash\x18\x01\x20\x01(\tR\x04hash\"/\n\x15GetBlockHeightRequest\x12\
    \x16\n\x06height\x18\x01\x20\x01(\rR\x06height\"T\n\x10GetBlocksRequest\
    \x12!\n\x0cstart_height\x18\x01\x20\x01(\rR\x0bstartHeight\x12\x1d\n\nen\
    d_height\x18\x02\x20\x01(\rR\tendHeight\"8\n\x11GetBlocksResponse\x12#\n\
    \x06blocks\x18\x01\x20\x03(\x0b2\x0b.bc.BcBlockR\x06blocks\"{\n\x17GetRo\
    veredBlocksRequest\x12\x1e\n\nblockchain\x18\x01\x20\x01(\tR\nblockchain\
    \x12!\n\x0cstart_height\x18\x02\x20\x01(\rR\x0bstartHeight\x12\x1d\n\nen\
    d_height\x18\x03\x20\x01(\rR\tendHeight\"L\n\x15GetRawMempoolResponse\
    \x123\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x0f.bc.TransactionR\x0ctra\
    nsactions\"=\n\x18GetRoveredBlocksResponse\x12!\n\x06blocks\x18\x01\x20\
    \x03(\x0b2\t.bc.BlockR\x06blocks\"\"\n\x0cGetTxRequest\x12\x12\n\x04hash\
    \x18\x01\x20\x01(\tR\x04hash\"H\n\x12GetMarkedTxRequest\x12\x1e\n\nblock\
    chain\x18\x01\x20\x01(\tR\nblockchain\x12\x12\n\x04hash\x18\x02\x20\x01(\
    \tR\x04hash\">\n\x12GetOutPointRequest\x12\x12\n\x04hash\x18\x01\x20\x01\
    (\tR\x04hash\x12\x14\n\x05index\x18\x02\x20\x01(\rR\x05index\"0\n\x16Get\
    TradeStatusResponse\x12\x16\n\x06status\x18\x01\x20\x01(\rR\x06status\"5\
    \n\x19GetOutPointStatusResponse\x12\x18\n\x07unspent\x18\x01\x20\x01(\
    \x08R\x07unspent\"!\n\x0bCurrentWork\x12\x12\n\x04work\x18\x01\x20\x01(\
    \tR\x04work*8\n\x1cRpcTransactionResponseStatus\x12\x0b\n\x07Success\x10\
    \0\x12\x0b\n\x07Failure\x10\x012\x87\x11\n\x02Bc\x12B\n\x13GetRoveredBlo\
    ckHash\x12\x1e.bc.GetRoveredBlockHashRequest\x1a\t.bc.Block\"\0\x12F\n\
    \x15GetRoveredBlockHeight\x12\x20.bc.GetRoveredBlockHeightRequest\x1a\t.\
    bc.Block\"\0\x12O\n\x10GetRoveredBlocks\x12\x1b.bc.GetRoveredBlocksReque\
    st\x1a\x1c.bc.GetRoveredBlocksResponse\"\0\x12B\n\x16GetLatestRoveredBlo\
    cks\x12\x08.bc.Null\x1a\x1c.bc.GetRoveredBlocksResponse\"\0\x126\n\x0cGe\
    tBlockHash\x12\x17.bc.GetBlockHashRequest\x1a\x0b.bc.BcBlock\"\0\x12:\n\
    \x0eGetBlockHeight\x12\x19.bc.GetBlockHeightRequest\x1a\x0b.bc.BcBlock\"\
    \0\x12:\n\tGetBlocks\x12\x14.bc.GetBlocksRequest\x1a\x15.bc.GetBlocksRes\
    ponse\"\0\x12)\n\x0eGetLatestBlock\x12\x08.bc.Null\x1a\x0b.bc.BcBlock\"\
    \0\x12,\n\x05GetTx\x12\x10.bc.GetTxRequest\x1a\x0f.bc.Transaction\"\0\
    \x12>\n\x0bGetMarkedTx\x12\x16.bc.GetMarkedTxRequest\x1a\x15.bc.MarkedTr\
    ansaction\"\0\x12F\n\x0eGetTradeStatus\x12\x16.bc.GetOutPointRequest\x1a\
    \x1a.bc.GetTradeStatusResponse\"\0\x12L\n\x11GetOutpointStatus\x12\x16.b\
    c.GetOutPointRequest\x1a\x1d.bc.GetOutPointStatusResponse\"\0\x12;\n\x0e\
    GetTxClaimedBy\x12\x16.bc.GetOutPointRequest\x1a\x0f.bc.Transaction\"\0\
    \x126\n\rGetRawMempool\x12\x08.bc.Null\x1a\x19.bc.GetRawMempoolResponse\
    \"\0\x12/\n\x0cGetBlockByTx\x12\x10.bc.GetTxRequest\x1a\x0b.bc.BcBlock\"\
    \0\x12A\n\x1aGetRoveredBlockForMarkedTx\x12\x16.bc.GetMarkedTxRequest\
    \x1a\t.bc.Block\"\0\x12$\n\x04Help\x12\x08.bc.Null\x1a\x10.bc.HelpRespon\
    se\"\0\x12&\n\x05Stats\x12\x08.bc.Null\x1a\x11.bc.StatsResponse\"\0\x129\
    \n\x05NewTx\x12\x12.bc.RpcTransaction\x1a\x1a.bc.RpcTransactionResponse\
    \"\0\x127\n\x06SendTx\x12\x0f.bc.Transaction\x1a\x1a.bc.RpcTransactionRe\
    sponse\"\0\x12=\n\nGetBalance\x12\x15.bc.GetBalanceRequest\x1a\x16.bc.Ge\
    tBalanceResponse\"\0\x124\n\tGetWallet\x12\x15.bc.GetBalanceRequest\x1a\
    \x0e.bc.WalletData\"\0\x12@\n\x15GetSpendableOutpoints\x12\x15.bc.GetBal\
    anceRequest\x1a\x0e.bc.WalletData\"\0\x12a\n\x16GetSpendableCollateral\
    \x12!.bc.GetSpendableCollateralRequest\x1a\".bc.GetSpendableCollateralRe\
    sponse\"\0\x12a\n\x16GetUnlockTakerTxParams\x12!.bc.GetUnlockTakerTxPara\
    msRequest\x1a\".bc.GetUnlockTakerTxParamsResponse\"\0\x12;\n\x0cGetTrans\
    fers\x12\x13.bc.TransferRequest\x1a\x14.bc.TransferResponse\"\0\x126\n\r\
    GetOpenOrders\x12\x08.bc.Null\x1a\x19.bc.GetOpenOrdersResponse\"\0\x12I\
    \n\x10GetMatchedOrders\x12\x15.bc.GetBalanceRequest\x1a\x1c.bc.GetMatche\
    dOrdersResponse\"\0\x12H\n\x12GetUnmatchedOrders\x12\x15.bc.GetBalanceRe\
    quest\x1a\x19.bc.GetOpenOrdersResponse\"\0\x12F\n\rGetUtxoLength\x12\x18\
    .bc.GetUtxoLengthRequest\x1a\x19.bc.GetUtxoLengthResponse\"\0\x12F\n\rGe\
    tStxoLength\x12\x18.bc.GetUtxoLengthRequest\x1a\x19.bc.GetUtxoLengthResp\
    onse\"\0\x12@\n\x0bGetBlake2bl\x12\x16.bc.GetBlake2blRequest\x1a\x17.bc.\
    GetBlake2blResponse\"\0\x12N\n\x15GetBcAddressViaVanity\x12\x18.bc.Vanit\
    yConvertRequest\x1a\x19.bc.VanityConvertResponse\"\0\x12-\n\x0eGetCurren\
    tWork\x12\x08.bc.Null\x1a\x0f.bc.CurrentWork\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
